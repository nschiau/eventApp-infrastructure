pipeline {
    agent any

    environment {
        SSH_CRED     = 'production-ssh'
        DOCKERHUB_CREDENTIALS = 'dockerhub-token'
        PROD_HOST    = '192.168.10.17'
        PROD_USER    = 'vagrant'
        REPO_INFRA   = 'https://github.com/nschiau/eventApp-infrastructure.git'
        INFRA_DIR    = '/home/vagrant/eventApp-infrastructure'
        K8S_NAMESPACE = 'eventapp-prod'
        REPO_BE = 'https://github.com/nschiau/eventApp-backend.git'
        REPO_FE = 'https://github.com/nschiau/eventApp-frontend.git'
        IMAGE_REPO = 'nschiau/eventapp'
        BE_TAG_BUILD = "be-prod-${BUILD_NUMBER}"
        FE_TAG_BUILD = "fe-prod-${BUILD_NUMBER}"
    }

    stages {
        stage('Checkout (production branches)') {
            parallel {
                stage('Checkout Backend') {
                    steps {
                        dir('backend') {
                            git branch: 'prod', url: env.REPO_BE
                        }
                    }
                }
                stage('Checkout Frontend') {
                    steps {
                        dir('frontend') {
                            git branch: 'prod', url: env.REPO_FE
                        }
                    }
                }
            }
        }

        stage('Docker Build & Push') {
            parallel {
                stage('Backend Docker Image') {
                    steps {
                        dir('backend') {
                            script {
                                def image = docker.build(
                                    "${IMAGE_REPO}:${BE_TAG_BUILD}",
                                    '-f src/EventHorizon.Api/Dockerfile .'
                                )
                                docker.withRegistry('', DOCKERHUB_CREDENTIALS) {
                                    image.push()
                                }
                            }
                        }
                    }
                }

                stage('Frontend Docker Image') {
                    steps {
                        dir('frontend') {
                            script {
                                def image = docker.build(
                                    "${IMAGE_REPO}:${FE_TAG_BUILD}",
                                    '.'
                                )
                                docker.withRegistry('', DOCKERHUB_CREDENTIALS) {
                                    image.push()
                                }
                            }
                        }
                    }
                }
            }
        }

        stage('Deploy to Production (Blue-Green Backend)') {
            stages {
                stage('Clone or Update Infrastructure Repo') {
                    steps {
                        sshagent(credentials: [SSH_CRED]) {
                            sh """
                            echo "[1/5] Cloning or updating infrastructure repo on PROD VM..."
                            ssh -o StrictHostKeyChecking=no ${PROD_USER}@${PROD_HOST} '
                                if [ ! -d "${INFRA_DIR}/.git" ]; then
                                    echo "Cloning repo fresh..."
                                    git clone ${REPO_INFRA} ${INFRA_DIR}
                                else
                                    cd ${INFRA_DIR}
                                    git fetch origin
                                    git reset --hard origin/main
                                fi
                            '
                            """
                        }
                    }
                }

                stage('Ensure Minikube Running') {
                    steps {
                        sshagent(credentials: [SSH_CRED]) {
                            sh """
                            ssh -o StrictHostKeyChecking=no ${PROD_USER}@${PROD_HOST} '
                                echo "[Pre-check] Ensuring Minikube is running..."
                                if ! minikube status | grep -q "apiserver: Running"; then
                                    echo "Starting Minikube..."
                                    minikube start --driver=docker --cpus=2 --memory=3072 --disk-size=20g --addons=ingress
                                fi
                                kubectl config use-context minikube || true
                                kubectl get nodes
                            '
                            """
                        }
                    }
                }

                stage('Create Docker Pull Secret in Kubernetes') {
                    steps {
                        sshagent(credentials: [SSH_CRED]) {
                            withCredentials([usernamePassword(credentialsId: "${DOCKERHUB_CREDENTIALS}",
                                usernameVariable: 'DOCKER_USER',
                                passwordVariable: 'DOCKER_PASS')]) {
                                sh """
                                echo "[Pre-deploy] Creating/Updating Docker registry secret in cluster..."
                                ssh -o StrictHostKeyChecking=no ${PROD_USER}@${PROD_HOST} '
                                    kubectl create secret docker-registry regcred \
                                        --docker-server=https://index.docker.io/v1/ \
                                        --docker-username="${DOCKER_USER}" \
                                        --docker-password="${DOCKER_PASS}" \
                                        --namespace=${K8S_NAMESPACE} \
                                        --dry-run=client -o yaml | kubectl apply -f -
                                '
                                """
                            }
                        }
                    }
                }

                stage('Apply Database Manifests') {
                    steps {
                        sshagent(credentials: [SSH_CRED]) {
                            sh """
                            echo "[2/5] Applying PostgreSQL StatefulSet and Service..."
                            ssh -o StrictHostKeyChecking=no ${PROD_USER}@${PROD_HOST} '
                                set -e
                                cd ${INFRA_DIR}/prod
                                kubectl apply -f namespace.yaml || true 

                                cd ${INFRA_DIR}/prod/database
                                kubectl apply -f . -n ${K8S_NAMESPACE}
                                kubectl get pods -n ${K8S_NAMESPACE} | grep db || true
                            '
                            """
                        }
                    }
                }

               stage('Deploy Backend (Blue-Green)') {
                    steps {
                        sshagent(credentials: [SSH_CRED]) {
                            script {
                                echo "[3/5] Detecting active backend color and deploying new version..."

                                // Detect which color is currently active
                                def currentColor = sh(
                                    script: """ssh -o StrictHostKeyChecking=no ${PROD_USER}@${PROD_HOST} \
                                        "kubectl get svc eventapp-be-svc -n ${K8S_NAMESPACE} -o jsonpath='{.spec.selector.version}' || echo blue" """,
                                    returnStdout: true
                                ).trim()
                                env.BE_CURRENT_COLOR = currentColor ?: "blue"
                                env.BE_NEW_COLOR = (env.BE_CURRENT_COLOR == "blue") ? "green" : "blue"

                                echo "Active backend color: ${BE_CURRENT_COLOR}"
                                echo "New backend color to deploy: ${BE_NEW_COLOR}"

                                // Deploy the new backend version
                                sh """
                                ssh -o StrictHostKeyChecking=no ${PROD_USER}@${PROD_HOST} '
                                    set -e
                                    cd ${INFRA_DIR}/prod
                                    echo "Applying deployment for eventapp-be-${BE_NEW_COLOR}..."
                                    sed -e "s/\\\${COLOR}/${BE_NEW_COLOR}/g" \
                                        -e "s/\\\${BUILD_TAG}/${BE_TAG_BUILD}/g" \
                                        be-deployment.yaml | kubectl apply -n ${K8S_NAMESPACE} -f -

                                    echo "Waiting for rollout of eventapp-be-${BE_NEW_COLOR}..."
                                    kubectl rollout status deployment/eventapp-be-${BE_NEW_COLOR} -n ${K8S_NAMESPACE}
                                '
                                """
                            }
                        }
                    }
                }

                stage('Deploy Frontend (Blue-Green)') {
                    steps {
                        sshagent(credentials: ["${SSH_CRED}"]) {
                            script {
                                echo "[4/8] Detecting active frontend color and deploying new version..."

                                //Detect which color is currently active
                                def currentColor = sh(
                                    script: """ssh -o StrictHostKeyChecking=no ${PROD_USER}@${PROD_HOST} \
                                        "kubectl get svc eventapp-fe-svc -n ${K8S_NAMESPACE} -o jsonpath='{.spec.selector.version}' || echo blue" """,
                                    returnStdout: true
                                ).trim()
                                env.FE_CURRENT_COLOR = currentColor ?: "blue"
                                env.FE_NEW_COLOR = (env.FE_CURRENT_COLOR == "blue") ? "green" : "blue"

                                echo "Active frontend color: ${FE_CURRENT_COLOR}"
                                echo "New frontend color to deploy: ${FE_NEW_COLOR}"

                                //Deploy the new frontend version
                                sh """
                                ssh -o StrictHostKeyChecking=no ${PROD_USER}@${PROD_HOST} '
                                    set -e
                                    cd ${INFRA_DIR}/prod
                                    echo "Applying deployment for eventapp-fe-${FE_NEW_COLOR}..."
                                    sed -e "s/\\\${COLOR}/${FE_NEW_COLOR}/g" \
                                        -e "s/\\\${BUILD_TAG}/${FE_TAG_BUILD}/g" \
                                        fe-deployment.yaml | kubectl apply -n ${K8S_NAMESPACE} -f -

                                    echo "Waiting for rollout of eventapp-fe-${FE_NEW_COLOR}..."
                                    kubectl rollout status deployment/eventapp-fe-${FE_NEW_COLOR} -n ${K8S_NAMESPACE}
                                '
                                """
                            }
                        }
                    }
                }

                stage('Apply Ingress Routes') {
                    steps {
                        sshagent(credentials: [SSH_CRED]) {
                            sh """
                            ssh -o StrictHostKeyChecking=no ${PROD_USER}@${PROD_HOST} '
                                cd ${INFRA_DIR}/prod
                                kubectl delete ingress eventapp-ingress -n ${K8S_NAMESPACE} --ignore-not-found=true
                                kubectl apply -f be-ingress.yaml -n ${K8S_NAMESPACE}
                                kubectl apply -f fe-ingress.yaml -n ${K8S_NAMESPACE}
                                kubectl get ingress -n ${K8S_NAMESPACE}
                            '
                            """
                        }
                    }
                }

                stage('Verify New Backend Pods Health (Pre-switch)') {
                    steps {
                        sshagent(credentials: [SSH_CRED]) {
                            sh """
                                echo "[Health Check] Verifying new backend pods (${BE_NEW_COLOR}) before switching traffic..."
                                ssh -o StrictHostKeyChecking=no ${PROD_USER}@${PROD_HOST} bash -c '
                                    set -e
                                    BE_NEW_COLOR="${BE_NEW_COLOR}"
                                    NAMESPACE="${K8S_NAMESPACE}"

                                    echo "Verifying backend color: \$BE_NEW_COLOR in namespace: \$NAMESPACE"

                                    POD_IP=\$(kubectl get pods -n \$NAMESPACE -l app=eventapp-be,version=\$BE_NEW_COLOR -o jsonpath="{.items[0].status.podIP}")
                                    if [ -z "\$POD_IP" ]; then
                                        echo "❌ No pod IP found for version \$BE_NEW_COLOR"
                                        exit 1
                                    fi

                                    echo "Found backend pod IP: \$POD_IP — testing /health endpoint..."

                                    STATUS=\$(kubectl run tmp-curl --rm -i --restart=Never \
                                        --image=curlimages/curl -n \$NAMESPACE -- \
                                        curl -s -o /dev/null -w "%{http_code}" http://\$POD_IP:8080/health 2>/dev/null | grep -Eo "^[0-9]{3}" | head -n1)

                                    echo "Healthcheck returned: [\$STATUS]"

                                    if [ "\$STATUS" != "200" ]; then
                                        echo "❌ Health check failed for backend \$BE_NEW_COLOR (HTTP \$STATUS)"
                                        exit 1
                                    fi

                                    echo "✅ Backend \$BE_NEW_COLOR pods are healthy (HTTP 200)"
                                '
                            """
                        }
                    }
                }

                stage('Verify Frontend Health (New Color)') {
                    steps {
                        sshagent(credentials: ["${SSH_CRED}"]) {
                            sh """
                                echo "[5/8] Verifying health of new Frontend deployment..."
                                ssh -o StrictHostKeyChecking=no ${PROD_USER}@${PROD_HOST} bash -c '
                                    set -e
                                    FE_NEW_COLOR="${FE_NEW_COLOR}"
                                    NAMESPACE="${K8S_NAMESPACE}"

                                    echo "Verifying frontend color: \$FE_NEW_COLOR in namespace: \$NAMESPACE"

                                    POD_IP=\$(kubectl get pods -n \$NAMESPACE -l app=eventapp-fe,version=\$FE_NEW_COLOR -o jsonpath="{.items[0].status.podIP}")
                                    if [ -z "\$POD_IP" ]; then
                                        echo "❌ No frontend pod IP found for version \$FE_NEW_COLOR"
                                        exit 1
                                    fi

                                    echo "Found frontend pod IP: \$POD_IP — testing root endpoint..."

                                    STATUS=\$(kubectl run tmp-curl --rm -i --restart=Never \
                                        --image=curlimages/curl -n \$NAMESPACE -- \
                                        curl -s -o /dev/null -w "%{http_code}" http://\$POD_IP:80 2>/dev/null | grep -Eo "^[0-9]{3}" | head -n1)

                                    echo "Healthcheck returned: [\$STATUS]"

                                    if [ "\$STATUS" != "200" ]; then
                                        echo "❌ Health check failed for frontend \$FE_NEW_COLOR (HTTP \$STATUS)"
                                        exit 1
                                    fi

                                    echo "✅ Frontend \$FE_NEW_COLOR pods are healthy (HTTP 200)"
                                '
                            """
                        }
                    }
                }

                stage('Switch Traffic to New Color (Backend)') {
                    steps {
                        sshagent(credentials: [SSH_CRED]) {
                            sh """
                            echo "[Switching traffic to ${BE_NEW_COLOR}]"
                            ssh -o StrictHostKeyChecking=no ${PROD_USER}@${PROD_HOST} '
                                kubectl patch svc eventapp-be-svc -n ${K8S_NAMESPACE} \
                                    -p "{\\"spec\\":{\\"selector\\":{\\"app\\":\\"eventapp-be\\",\\"version\\":\\"${BE_NEW_COLOR}\\"}}}"
                            '
                            """
                        }
                    }
                }

                stage('Scale Down Old Deployment (Backend)') {
                    steps {
                        sshagent(credentials: [SSH_CRED]) {
                            sh """
                            echo "[Scale down old ${BE_CURRENT_COLOR} deployment]"
                            ssh -o StrictHostKeyChecking=no ${PROD_USER}@${PROD_HOST} '
                                kubectl scale deployment/eventapp-be-${BE_CURRENT_COLOR} -n ${K8S_NAMESPACE} --replicas=0 || true
                            '
                            """
                        }
                    }
                }

                stage('Switch Traffic to New Color (Frontend)') {
                    steps {
                        sshagent(credentials: ["${SSH_CRED}"]) {
                            sh """
                            echo "[6/8] Switching Frontend service traffic to ${FE_NEW_COLOR}..."
                            ssh -o StrictHostKeyChecking=no ${PROD_USER}@${PROD_HOST} '
                                kubectl patch svc eventapp-fe-svc -n ${K8S_NAMESPACE} \
                                    -p "{\\"spec\\":{\\"selector\\":{\\"app\\":\\"eventapp-fe\\",\\"version\\":\\"${FE_NEW_COLOR}\\"}}}"
                                echo "✅ Traffic switched to ${FE_NEW_COLOR} frontend deployment."
                            '
                            """
                        }
                    }
                }

                stage('Scale Down Old Deployment (Frontend)') {
                    steps {
                        sshagent(credentials: ["${SSH_CRED}"]) {
                            sh """
                            echo "[7/8] Scaling down old frontend deployment (${FE_CURRENT_COLOR})..."
                            ssh -o StrictHostKeyChecking=no ${PROD_USER}@${PROD_HOST} '
                                kubectl scale deployment/eventapp-fe-${FE_CURRENT_COLOR} -n ${K8S_NAMESPACE} --replicas=0 || true
                                echo "Old frontend deployment (${FE_CURRENT_COLOR}) scaled down."
                            '
                            """
                        }
                    }
                }
            }
        }

        stage('Post-Deployment Verification') {
            steps {
                sshagent(credentials: [SSH_CRED]) {
                    sh """
                    echo "[5/5] Verifying running resources on PROD..."
                    ssh -o StrictHostKeyChecking=no ${PROD_USER}@${PROD_HOST} '
                        echo "--- Pods ---"
                        kubectl get pods -n ${K8S_NAMESPACE} -o wide
                        echo "--- Services ---"
                        kubectl get svc -n ${K8S_NAMESPACE}
                        echo "--- Events ---"
                        kubectl get events -n ${K8S_NAMESPACE} --sort-by=.metadata.creationTimestamp | tail -n 10
                    '
                    """
                }
            }
        }
    }

    post {
        always {
            cleanWs()
        }
        success {
            echo 'Production Blue-Green deployment (Backend + Frontend) completed successfully.'
        }
        failure {
            echo 'Production deployment failed.'
        }
    }
}
