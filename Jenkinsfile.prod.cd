pipeline {
    agent any

    environment {
        SSH_CRED     = 'production-ssh'
        DOCKERHUB_CREDENTIALS = 'dockerhub-token'
        PROD_HOST    = '192.168.10.17'                            // prod VM IP
        PROD_USER    = 'vagrant'
        REPO_INFRA   = 'https://github.com/nschiau/eventApp-infrastructure.git'
        INFRA_DIR    = '/home/vagrant/eventApp-infrastructure'     // local repo path on prod VM
        K8S_NAMESPACE = 'eventapp-prod'
    }

    stages {
        stage('Deploy to Production (Blue Version)') {
            stages {
                stage('Clone or Update Infrastructure Repo') {
                    steps {
                        sshagent(credentials: ["${SSH_CRED}"]) {
                            sh """
                            echo "[1/4] Cloning or updating infrastructure repo on PROD VM..."
                            ssh -o StrictHostKeyChecking=no ${PROD_USER}@${PROD_HOST} '
                                if [ ! -d "${INFRA_DIR}/.git" ]; then
                                    echo "Cloning repo fresh..."
                                    git clone ${REPO_INFRA} ${INFRA_DIR}
                                else
                                    echo "Updating existing repo..."
                                    cd ${INFRA_DIR}
                                    git fetch origin
                                    git reset --hard origin/main
                                fi
                            '
                            """
                        }
                    }
                }

                stage('Ensure Minikube Running') {
                    steps {
                        sshagent(credentials: ["${SSH_CRED}"]) {
                            sh """
                            ssh -o StrictHostKeyChecking=no ${PROD_USER}@${PROD_HOST} '
                                echo "[Pre-check] Ensuring Minikube is running..."
                                if ! minikube status | grep -q "apiserver: Running"; then
                                    echo "Starting Minikube..."
                                    minikube start --driver=docker --cpus=2 --memory=3072 --disk-size=20g --addons=ingress
                                fi
                                kubectl config use-context minikube || true
                                echo "Cluster ready:"
                                kubectl get nodes
                            '
                            """
                        }
                    }
                }

                stage('Create Docker Pull Secret in Kubernetes') {
                    steps {
                        sshagent(credentials: ["${SSH_CRED}"]) {
                            withCredentials([usernamePassword(credentialsId: "${DOCKERHUB_CREDENTIALS}",
                                usernameVariable: 'DOCKER_USER',
                                passwordVariable: 'DOCKER_PASS')]) {
                                sh """
                                echo "[Pre-deploy] Creating/Updating Docker registry secret in cluster..."
                                ssh -o StrictHostKeyChecking=no ${PROD_USER}@${PROD_HOST} '
                                    kubectl create secret docker-registry regcred \
                                        --docker-server=https://index.docker.io/v1/ \
                                        --docker-username="${DOCKER_USER}" \
                                        --docker-password="${DOCKER_PASS}" \
                                        --docker-email="devops@example.com" \
                                        --namespace=${K8S_NAMESPACE} \
                                        --dry-run=client -o yaml | kubectl apply -f -
                                '
                                """
                                }
                        }
                    }
                }

                stage('Apply Database Manifests') {
                    steps {
                        sshagent(credentials: ["${SSH_CRED}"]) {
                            sh """
                            echo "[2/4] Applying PostgreSQL StatefulSet and Service..."
                            ssh -o StrictHostKeyChecking=no ${PROD_USER}@${PROD_HOST} '
                                set -e
                                # Apply namespace first (from prod folder)
                                cd ${INFRA_DIR}/prod
                                kubectl apply -f namespace.yaml || true

                                # Apply database manifests (from prod/database folder)
                                cd ${INFRA_DIR}/prod/database
                                kubectl apply -f . -n ${K8S_NAMESPACE}

                                echo "Database applied. Checking pods..."
                                kubectl get pods -n ${K8S_NAMESPACE} | grep db || true
                            '
                            """
                        }
                    }
                }

                stage('Apply Backend (Blue) Deployment + Service') {
                    steps {
                        sshagent(credentials: ["${SSH_CRED}"]) {
                            sh """
                            echo "[3/4] Deploying Backend Blue version..."
                            ssh -o StrictHostKeyChecking=no ${PROD_USER}@${PROD_HOST} '
                                set -e
                                cd ${INFRA_DIR}/prod
                                kubectl apply -f be-blue-deployment.yaml -n ${K8S_NAMESPACE}
                                kubectl apply -f be-blue-green-service.yaml -n ${K8S_NAMESPACE}
                                echo "Backend blue deployment and service applied."
                            '
                            """
                        }
                    }
                }

                stage('Apply Frontend (Blue) Deployment + Service') {
                    steps {
                        sshagent(credentials: ["${SSH_CRED}"]) {
                            sh """
                            echo "[4/5] Deploying Frontend Blue version..."
                            ssh -o StrictHostKeyChecking=no ${PROD_USER}@${PROD_HOST} '
                                set -e
                                cd ${INFRA_DIR}/prod

                                echo "Applying frontend blue deployment and service..."
                                kubectl apply -f fe-blue-deployment.yaml -n ${K8S_NAMESPACE}
                                kubectl apply -f fe-blue-green-service.yaml -n ${K8S_NAMESPACE}

                                echo "Frontend blue deployment and service applied."
                                echo "Fetching frontend pods and service..."
                                kubectl get pods -n ${K8S_NAMESPACE} -o wide | grep frontend || true
                                kubectl get svc -n ${K8S_NAMESPACE} | grep fe || true
                            '
                            """
                        }
                    }
                }

                stage('Apply Ingress Routes') {
                    steps {
                        sshagent(credentials: ["${SSH_CRED}"]) {
                            sh """
                            ssh -o StrictHostKeyChecking=no ${PROD_USER}@${PROD_HOST} '
                                cd /home/vagrant/eventApp-infrastructure/prod
                                kubectl delete ingress eventapp-ingress -n eventapp-prod --ignore-not-found=true
                                kubectl apply -f be-ingress.yaml -n eventapp-prod
                                kubectl apply -f fe-ingress.yaml -n eventapp-prod
                                kubectl get ingress -n eventapp-prod
                            '
                            """
                        }
                    }
                }

                stage('Post-Deployment Verification') {
                    steps {
                        sshagent(credentials: ["${SSH_CRED}"]) {
                            sh """
                            echo "[5/5] Verifying running resources on PROD..."
                            ssh -o StrictHostKeyChecking=no ${PROD_USER}@${PROD_HOST} '
                                echo "--- Pods ---"
                                kubectl get pods -n ${K8S_NAMESPACE} -o wide
                                echo "--- Services ---"
                                kubectl get svc -n ${K8S_NAMESPACE}
                                echo "--- Events ---"
                                kubectl get events -n ${K8S_NAMESPACE} --sort-by=.metadata.creationTimestamp | tail -n 10
                            '
                            """
                        }
                    }
                }
            }
        }
    }

    post {
        always {
            cleanWs()
        }
        success {
            echo 'Production deployment (Blue) completed successfully.'
        }
        failure {
            echo 'Production deployment failed.'
        }
    }
}
