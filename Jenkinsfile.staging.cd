pipeline {
    agent any

    triggers {
        githubPush()
    }

    tools {
        nodejs 'NodeJS'
    }

    environment {
        REPO_BE = 'https://github.com/nschiau/eventApp-backend.git'
        REPO_FE = 'https://github.com/nschiau/eventApp-frontend.git'
        DOCKERHUB_CREDENTIALS = 'dockerhub-token'
        IMAGE_REPO = 'nschiau/eventapp'
        SSH_CRED = 'staging-ssh'
        STAGING_HOST = '192.168.10.16'
        STAGING_USER = 'vagrant'
        BE_TAG_BUILD = "be-staging-${BUILD_NUMBER}"
        FE_TAG_BUILD = "fe-staging-${BUILD_NUMBER}"
        BE_TAG_LATEST = 'be-staging'
        FE_TAG_LATEST = 'fe-staging'
        BE_PORT = '5500'
        FE_PORT = '3000'
        BE_CONTAINER_NAME = 'eventapp-be'
        FE_CONTAINER_NAME = 'eventapp-fe'
        DB_CONTAINER = 'eventapp-db'
        DB_VOLUME = 'eventapp_pgdata'
        NETWORK = 'eventapp-net'
        BACKEND_URL = 'http://eventapp-be:8080'
    }

    stages {
        stage('Checkout (staging)') {
            parallel {
                stage('Checkout Backend') {
                    steps {
                        dir('backend') {
                            git branch: 'staging', url: env.REPO_BE
                        }
                    }
                }
                stage('Checkout Frontend') {
                    steps {
                        dir('frontend') {
                            git branch: 'staging', url: env.REPO_FE
                        }
                    }
                }
            }
        }

        stage('Build and Test') {
            parallel {
                stage('Backend: Restore, Build and Test (.NET)') {
                    environment {
                        DOTNET_CLI_TELEMETRY_OPTOUT = '1'
                    }
                    steps {
                        dir('backend') {
                            sh '''
                            set -e
                            dotnet --info
                            dotnet restore src/EventHorizon.Api/EventHorizon.Api.csproj
                            dotnet build --no-restore src/EventHorizon.Api/EventHorizon.Api.csproj --configuration Release
                            dotnet test tests/EventHorizon.Api.Tests/EventHorizon.Api.Tests.csproj
                        '''
                        }
                    }
                }
                stage('Frontend: Install dependencies, Build and Test (Node)') {
                    steps {
                        dir('frontend') {
                            sh '''
                            set -e
                            node -v
                            npm ci || npm install
                            npm run build
                            npm test
                        '''
                        }
                    }
                }
            }
        }

        stage('Docker Build & Push') {
            parallel {
                stage('Backend Docker Image') {
                    steps {
                        dir('backend') {
                            script {
                                // Build image with branch-specific tag
                                def image = docker.build(
                                    "${IMAGE_REPO}:${BE_TAG_BUILD}",
                                    '-f src/EventHorizon.Api/Dockerfile .'
                                )

                                // Push both the unique tag and the staging tag
                                docker.withRegistry('', DOCKERHUB_CREDENTIALS) {
                                    image.push()
                                    image.push(BE_TAG_LATEST)
                                }
                            }
                        }
                    }
                }

                stage('Frontend Docker Image') {
                    steps {
                        dir('frontend') {
                            script {
                                // Build image using Dockerfile from repo root
                                def image = docker.build(
                                "${IMAGE_REPO}:${FE_TAG_BUILD}",
                                '.'
                                )

                                // Push both the unique tag and the staging tag
                                docker.withRegistry('', DOCKERHUB_CREDENTIALS) {
                                    image.push()
                                    image.push(FE_TAG_LATEST)
                                }
                            }
                        }
                    }
                }
            }
        }

        stage('Deploy to Staging') {
            stages {
                stage('Setup Network') {
                    steps {
                        sshagent(credentials: ["${SSH_CRED}"]) {
                            sh """
                    ssh -o StrictHostKeyChecking=no ${STAGING_USER}@${STAGING_HOST} '
                        echo "Creating Docker network if not exists..."
                        docker network inspect ${NETWORK} >/dev/null 2>&1 || docker network create ${NETWORK}
                    '
                    """
                        }
                    }
                }

                stage('Setup Database') {
                    steps {
                        sshagent(credentials: ["${SSH_CRED}"]) {
                            sh """
                        ssh -o StrictHostKeyChecking=no ${STAGING_USER}@${STAGING_HOST} '
                            echo "Checking PostgreSQL container..."
                            if [ -z "\$(docker ps -aq -f name=${DB_CONTAINER})" ]; then
                                echo "Creating PostgreSQL container..."
                                docker run -d \\
                                    --name ${DB_CONTAINER} \\
                                    --network ${NETWORK} \\
                                    -v ${DB_VOLUME}:/var/lib/postgresql/data \\
                                    -e POSTGRES_USER=postgres \\
                                    -e POSTGRES_PASSWORD=postgres \\
                                    -e POSTGRES_DB=eventhorizon \\
                                    postgres:16
                            else
                                echo "PostgreSQL container already exists — starting if stopped."
                                docker start ${DB_CONTAINER} || true
                            fi
                        '
                        """
                        }
                    }
                }

                stage('Initialize Database') {
                    steps {
                        sshagent(credentials: ["${SSH_CRED}"]) {
                            withCredentials([usernamePassword(credentialsId: "${DOCKERHUB_CREDENTIALS}",
                            usernameVariable: 'DOCKER_USER',
                            passwordVariable: 'DOCKER_PASS')]) {
                                sh """#!/bin/bash
                            ssh -o StrictHostKeyChecking=no ${STAGING_USER}@${STAGING_HOST} \"bash -s\" << 'EOL'
                                set -e
                                echo "Waiting for PostgreSQL to be ready..."
                                for i in {1..15}; do
                                    if docker exec ${DB_CONTAINER} pg_isready -U postgres -d eventhorizon >/dev/null 2>&1; then
                                        echo "PostgreSQL is ready!"
                                        break
                                    fi
                                    echo "Waiting for DB... (\$i/15)"
                                    sleep 3
                                done

                                # Re-login to Docker Hub with provided credentials
                                echo "${DOCKER_PASS}" | docker login -u "${DOCKER_USER}" --password-stdin

                                echo "Pulling latest backend image..."
                                docker pull ${IMAGE_REPO}:${BE_TAG_LATEST}

                                echo "Extracting init-db.sql from backend image..."
                                docker create --name temp ${IMAGE_REPO}:${BE_TAG_LATEST} >/dev/null
                                docker cp temp:/app/init-db.sql ./init-db.sql
                                docker rm temp >/dev/null

                                echo "Applying database initialization script..."
                                docker exec -i ${DB_CONTAINER} psql -U postgres -d eventhorizon < ./init-db.sql || true
                                rm -f ./init-db.sql
                                echo "Database initialization completed."
EOL
                        """
                        }
                        }
                    }
                }

                stage('Deploy Backend App') {
                    steps {
                        sshagent(credentials: ["${SSH_CRED}"]) {
                            sh """
                            ssh -o StrictHostKeyChecking=no ${STAGING_USER}@${STAGING_HOST} '
                                echo "Stopping old backend container (if exists)..."
                                docker stop ${BE_CONTAINER_NAME} || true
                                docker rm ${BE_CONTAINER_NAME} || true

                                echo "Running new backend container..."
                                docker run -d \\
                                    --name ${BE_CONTAINER_NAME} \\
                                    --network ${NETWORK} \\
                                    -p ${BE_PORT}:8080 \\
                                    -e ConnectionStrings__DefaultConnection="Host=${DB_CONTAINER};Database=eventhorizon;Username=postgres;Password=postgres" \\
                                    ${IMAGE_REPO}:${BE_TAG_LATEST}

                                echo "Backend container deployed on port ${BE_PORT}"
                            '
                            """
                        }
                    }
                }

                stage('Deploy Frontend App') {
                    steps {
                        sshagent(credentials: ["${SSH_CRED}"]) {
                            sh """
                            ssh -o StrictHostKeyChecking=no ${STAGING_USER}@${STAGING_HOST} '
                                echo "Stopping old frontend container (if exists)..."
                                docker stop ${FE_CONTAINER_NAME} || true
                                docker rm ${FE_CONTAINER_NAME} || true

                                echo "Pulling latest frontend image..."
                                docker pull ${IMAGE_REPO}:${FE_TAG_LATEST}

                                echo "Running new frontend container..."
                                docker run -d \\
                                    --name ${FE_CONTAINER_NAME} \\
                                    --network ${NETWORK} \\
                                    -p ${FE_PORT}:80 \\
                                    -e REACT_APP_API_BASE_URL=${BACKEND_URL} \\
                                    ${IMAGE_REPO}:${FE_TAG_LATEST}

                                echo "Frontend container deployed on port ${FE_PORT}"
                            '
                            """
                        }
                    }
                }

                stage('Post-Deployment Verification') {
                    steps {
                        sshagent(credentials: ["${SSH_CRED}"]) {
                            sh """#!/bin/bash
                                set -e
                                ssh -o StrictHostKeyChecking=no ${STAGING_USER}@${STAGING_HOST} '
                                    echo "[5/5] Verifying running containers..."
                                    docker ps --format "table {{.Names}}\\t{{.Image}}\\t{{.Ports}}"
                                '
                                """
                        }
                    }
                }

                stage('Promote to Production (Auto Merge)') {
                    steps {
                        script {
                            def repos = [env.REPO_BE, env.REPO_FE]

                            for (repoUrl in repos) {
                                def repoName = repoUrl.split('/').last().replace('.git', '')
                                def repo = "nschiau/${repoName}"

                                echo "Checking for differences between staging and production in ${repo}..."

                                sh """
                                    rm -rf tmp_repo
                                    git clone --quiet ${repoUrl} tmp_repo
                                    cd tmp_repo
                                    git fetch origin staging
                                    git fetch origin prod
                                """

                                def diffCount = sh(
                                    script: 'cd tmp_repo && git diff --name-only origin/prod..origin/staging | wc -l',
                                    returnStdout: true
                                ).trim()

                                if (diffCount.toInteger() > 0) {
                                    echo "Found ${diffCount} file(s) different — creating PR staging → prod in ${repo}..."

                                    sh """
                                        cd tmp_repo
                                        gh pr create --base prod --head staging \
                                            --title "Promote staging → prod" \
                                            --body "Automated promotion triggered by latest staging commit." \
                                            --repo ${repo} || echo 'PR already exists'

                                        gh pr merge staging --merge --repo ${repo} || echo 'PR already merged or not mergeable'
                                    """
                                } else {
                                    echo "✅ No unpromoted changes in ${repo}. Skipping PR creation."
                                }

                                sh 'rm -rf tmp_repo'
                            }
                        }
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                echo 'Cleaning workspace...'
                cleanWs()
            }
        }
        success {
            echo 'Staging CD pipeline completed successfully.'
        }
        failure {
            echo 'Staging CD pipeline failed.'
        }
    }
}
